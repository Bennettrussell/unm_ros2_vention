#!/usr/bin/env python3

"""
Vention State Machine (ROS 2 Version)
-------------------------------------

Overview:
 - This node controls a single dual-gantry rail system using the MachineMotion API.
 - It manages different operation modes: 
    1) READY_TO_MOVE
    2) VELOCITY_SERVO
    3) POSITION_MOVE
    4) POSITION_SERVO
    5) ERROR
 - It provides services for transitioning between modes (Trigger or custom services).
 - It subscribes to collision messages, position/velocity commands, and publishes the rail's state.
 - Internally, it uses a P-controller for motion commands and a queue of waypoints for position moves.
 - It also handles E-stop events from the MachineMotion library.

ROS 2 Mechanisms:
 - Inherits from rclpy.node.Node for ROS 2â€“style node capabilities.
 - Uses create_publisher(), create_subscription(), create_service(), and create_timer() to handle all ROS I/O.
 - Logs with self.get_logger().info/warn/error instead of rospy.loginfo/warn/error.
 - Tracks time with self.get_clock().now() instead of rospy.Time.now().
"""

import rclpy
from rclpy.node import Node

import argparse
import threading
import numpy as np
from queue import Queue
from enum import Enum

# ROS 2 standard messages & services
from std_msgs.msg import Float64, String, Bool
from sensor_msgs.msg import JointState
from std_srvs.srv import Trigger, Trigger_Request, Trigger_Response

# Your custom service (auto-generated by rosidl in ROS 2)
from vention_control.srv import PositionMove

# External dependencies (ensure they're installed in your environment)
import roboticstoolbox as rtb
from MachineMotion import MachineMotionV2OneDrive


class VentionStateMachine(Node):
    """ROS 2 Node controlling a single dual-gantry rail system via MachineMotion APIs."""

    class State(Enum):
        INITIALIZING = 0
        READY_TO_MOVE = 1
        VELOCITY_SERVO = 2
        POSITION_MOVE = 3
        POSITION_SERVO = 4
        ERROR = 5

    def __init__(self, node_name: str, vention_ip: str, sampling_frequency: float = 100.0):
        """
        Initialize the VentionStateMachine node.
        
        :param node_name: Name of the ROS 2 node.
        :param vention_ip: IP address of the Vention MachineMotion controller.
        :param sampling_frequency: Main control loop frequency (Hz).
        """
        super().__init__(node_name)

        # --- MachineMotion Setup ---
        self.mm = MachineMotionV2OneDrive(machineIp=vention_ip)
        self.axis = 1  # Single axis to control
        self.max_velocity = 500       # mm/s
        self.max_acceleration = 3000  # mm/s^2
        self.mm.setSpeed(self.max_velocity)
        self.mm.setAcceleration(self.max_acceleration)

        self.sampling_frequency = sampling_frequency

        # --- State Machine Variables ---
        self.state = self.State.INITIALIZING
        self.state_transition_lock = threading.Lock()

        # --- Position Control ---
        self.position_value = self.mm.getActualPositions(self.axis)
        self.Kp = 6  # Proportional gain for P-controller
        self.polish_position = False  # Flag for final positioning
        self.position_queue = Queue()  # Queue of waypoints for POSITION_MOVE
        self.position_queue_lock = threading.Lock()

        # --- Collision Handling ---
        self.collision_detected = False
        self.collision_lock = threading.Lock()

        # --- Velocity Control ---
        self.target_joint_velocity_message = Float64()
        self.target_velocity_lock = threading.Lock()
        self.command_timeout_sec = 15.0 / self.sampling_frequency
        self.last_velocity_command_time = self.get_clock().now()

        # --- Position Servo Control ---
        self.target_joint_position_servo_message = Float64()
        self.target_position_lock = threading.Lock()

        # --- E-Stop ---
        self.estop_triggered = False
        # Bind E-Stop event from MachineMotion (library-specific feature)
        self.mm.bindeStopEvent(self.handle_estop_status)

        # --- ROS 2 Publishers ---
        self.state_pub = self.create_publisher(String, 'state', 10)
        self.joint_state_publisher = self.create_publisher(JointState, 'joint_state', 10)

        # --- ROS 2 Subscribers ---
        self.collision_checker_sub = self.create_subscription(
            Bool, '/min_dist_vio', self.collision_callback, 10
        )
        self.position_servo_command_sub = self.create_subscription(
            Float64, 'position_servo_command', self.update_target_position_servo, 10
        )
        self.velocity_command_sub = self.create_subscription(
            Float64, 'velocity_command', self.update_target_velocity, 10
        )

        # --- ROS 2 Services ---
        self.position_move_srv = self.create_service(
            PositionMove, 'position_move', self.transition_to_position_move_mode
        )
        self.position_servo_srv = self.create_service(
            Trigger, 'position_servo', self.transition_to_position_servo_mode
        )
        self.velocity_mode_srv = self.create_service(
            Trigger, 'velocity_servo', self.transition_to_velocity_mode
        )
        self.stop_srv = self.create_service(
            Trigger, 'stop', self.stop
        )
        self.error_reset_srv = self.create_service(
            Trigger, 'error_reset', self.error_reset
        )

        # --- Timer for Main Control Loop (replaces rospy.Timer) ---
        timer_period = 1.0 / self.sampling_frequency
        self.timer = self.create_timer(timer_period, self.run)

        # Transition to READY_TO_MOVE
        self.state = self.State.READY_TO_MOVE
        self.get_logger().info('VentionStateMachine node initialized and READY_TO_MOVE.')

    def run(self):
        """
        Main control loop, called periodically by self.timer.
        Handles publishing state, joint state, and mode-specific logic.
        """
        with self.state_transition_lock:
            current_time = self.get_clock().now()

            # Publish current high-level state
            state_msg = String()
            state_msg.data = self.state.name
            self.state_pub.publish(state_msg)

            # Publish current joint state
            js = JointState()
            js.header.stamp = current_time.to_msg()
            js.name = ['carriage']
            js.position = [self.mm.getActualPositions(self.axis) / 1000.0]
            js.velocity = [self.mm.getActualSpeeds(self.axis) / 1000.0]
            js.effort = [0.0]
            self.joint_state_publisher.publish(js)

            # Collision logic -> immediate ERROR if collision is true
            if self.collision_detected:
                self.mm.stopAxis(self.axis)
                self.state = self.State.ERROR

            # State-based behavior
            if self.state in [self.State.READY_TO_MOVE, self.State.ERROR]:
                pass  # Idle (ERROR means do nothing further here)

            elif self.state == self.State.POSITION_MOVE:
                self.handle_position_move_state()

            elif self.state == self.State.POSITION_SERVO:
                self.handle_position_servo_state()

            elif self.state == self.State.VELOCITY_SERVO:
                self.handle_velocity_servo_state(current_time)

    # -------------------------
    #   Mode-Specific Handlers
    # -------------------------
    def handle_position_move_state(self):
        """Implements waypoint-based position moves with optional final 'polish' step."""
        with self.target_position_lock:
            if (not self.position_queue.empty() or
                    (hasattr(self, 'feasible_path') and self.feasible_path.size > 0) or
                    self.polish_position):

                # If no feasible path attribute yet, generate one
                if not hasattr(self, 'feasible_path'):
                    current_position = self.mm.getActualPositions(self.axis)
                    self.next_waypoint = self.position_queue.get()
                    self.feasible_path = self.draw_feasible_path([current_position, self.next_waypoint])

                # If the path is done but the queue still has waypoints, start a new path
                elif self.feasible_path.size == 0 and not self.position_queue.empty():
                    current_position = self.mm.getActualPositions(self.axis)
                    self.next_waypoint = self.position_queue.get()
                    self.feasible_path = self.draw_feasible_path([current_position, self.next_waypoint])

                # Final polishing of the position if needed
                if self.polish_position:
                    error = self.next_waypoint - self.mm.getActualPositions(self.axis)
                    output = self.update_control(error)
                    self.mm.moveContinuous(self.axis, output)

                # Traverse the feasible path if there is any
                if self.feasible_path.size > 0:
                    next_position = int(self.feasible_path[0])
                    self.feasible_path = self.feasible_path[1:]
                    error = next_position - self.mm.getActualPositions(self.axis)
                    output = self.update_control(error)
                    self.mm.moveContinuous(self.axis, output)

                # If path is empty and no more waypoints, check final position
                if self.feasible_path.size == 0 and self.position_queue.empty():
                    if abs(self.mm.getActualPositions(self.axis) - self.next_waypoint) < 0.5:
                        self.mm.stopAxis(self.axis)
                        self.polish_position = False
                        self.state = self.State.READY_TO_MOVE
                        self.get_logger().info('Position move complete')
                    else:
                        self.polish_position = True

    def handle_position_servo_state(self):
        """Continuously servo to a target position with a P-controller."""
        with self.target_position_lock:
            current_pos = self.mm.getActualPositions(self.axis)
            target = self.target_joint_position_servo_message.data

            # Limit large jumps to 10 mm at a time
            if abs(current_pos - target) > 10:
                if current_pos < target:
                    target = current_pos + 10
                else:
                    target = current_pos - 10
                self.target_joint_position_servo_message.data = target

            # P-control
            error = target - current_pos
            output = self.update_control(error)
            self.mm.moveContinuous(self.axis, output)

    def handle_velocity_servo_state(self, current_time):
        """Continuously servo the axis to a desired velocity, with a command timeout."""
        with self.target_velocity_lock:
            time_since_last_cmd = (current_time - self.last_velocity_command_time).nanoseconds * 1e-9
            if time_since_last_cmd > self.command_timeout_sec:
                # If velocity command is stale, send zero velocity
                velocity = 0.0
            else:
                velocity = self.target_joint_velocity_message.data

            self.mm.moveContinuous(self.axis, velocity)

    # ---------------------
    #   ROS 2 Service APIs
    # ---------------------
    def stop(self, request: Trigger_Request, response: Trigger_Response) -> Trigger_Response:
        """Stop the rail immediately."""
        self.mm.stopAxis(self.axis)
        response.success = True
        response.message = f'Stopped rail from {self.state.name}'
        return response

    def transition_to_velocity_mode(self, request: Trigger_Request, response: Trigger_Response) -> Trigger_Response:
        """Switch to VELOCITY_SERVO if the rail is READY_TO_MOVE."""
        with self.state_transition_lock:
            if self.state not in [self.State.READY_TO_MOVE]:
                self.get_logger().warn(f'Cannot transition from {self.state.name} to VELOCITY_SERVO')
                response.success = False
                response.message = f'Invalid transition: {self.state.name} â†’ VELOCITY_SERVO'
                return response

            self.state = self.State.VELOCITY_SERVO
            response.success = True
            response.message = f'Transitioned to {self.state.name}'
            return response

    def transition_to_position_move_mode(self,
                                         request: PositionMove.Request,
                                         response: PositionMove.Response) -> PositionMove.Response:
        """
        Move to POSITION_MOVE if allowed states, and optionally enqueue waypoints.
        """
        with self.state_transition_lock:
            allowed = [
                self.State.READY_TO_MOVE,
                self.State.VELOCITY_SERVO,
                self.State.POSITION_SERVO,
                self.State.POSITION_MOVE
            ]
            if self.state not in allowed:
                self.get_logger().warn(f'Cannot transition from {self.state.name} to POSITION_MOVE')
                response.success = False
                response.message = f'Invalid transition: {self.state.name} â†’ POSITION_MOVE'
                return response

            # Ensure rail is stopped if coming from VELOCITY_SERVO or POSITION_SERVO
            if self.state in [self.State.VELOCITY_SERVO, self.State.POSITION_SERVO]:
                speed = self.mm.getActualSpeeds(self.axis)
                if not np.isclose(speed, 0.0, atol=1e-4):
                    self.get_logger().warn('Cannot transition to POSITION_MOVE while in motion')
                    response.success = False
                    response.message = 'Rail is still moving'
                    return response

            # If already in POSITION_MOVE, just add new waypoints
            if self.state == self.State.POSITION_MOVE:
                with self.position_queue_lock:
                    if request.array_of_waypoints:
                        for p in request.array_of_waypoints:
                            self.position_queue.put(p)
                response.success = True
                response.message = 'Added new waypoints to queue'
                return response

            # Otherwise, transition to POSITION_MOVE, loading any new waypoints
            with self.position_queue_lock:
                if request.array_of_waypoints:
                    for p in request.array_of_waypoints:
                        self.position_queue.put(p)

            self.state = self.State.POSITION_MOVE
            response.success = True
            response.message = f'Transitioned to POSITION_MOVE'
            return response

    def transition_to_position_servo_mode(self,
                                          request: Trigger_Request,
                                          response: Trigger_Response) -> Trigger_Response:
        """Switch to POSITION_SERVO from READY_TO_MOVE."""
        with self.state_transition_lock:
            if self.state not in [self.State.READY_TO_MOVE]:
                self.get_logger().warn(f'Cannot transition from {self.state.name} to POSITION_SERVO')
                response.success = False
                response.message = f'Invalid transition: {self.state.name} â†’ POSITION_SERVO'
                return response

            # Initialize servo to current position
            self.target_joint_position_servo_message.data = self.mm.getActualPositions(self.axis)
            self.state = self.State.POSITION_SERVO
            response.success = True
            response.message = 'Transitioned to POSITION_SERVO'
            return response

    def error_reset(self, request: Trigger_Request, response: Trigger_Response) -> Trigger_Response:
        """Recover from ERROR state if E-Stop is not active."""
        with self.state_transition_lock:
            if self.state != self.State.ERROR:
                self.get_logger().warn('Cannot reset unless in ERROR state')
                response.success = False
                response.message = 'Not in ERROR state'
                return response

            if self.estop_triggered:
                self.get_logger().error('Cannot reset: E-Stop is active')
                response.success = False
                response.message = 'E-Stop triggered'
                return response

            self.state = self.State.READY_TO_MOVE
            response.success = True
            response.message = 'Error reset; now READY_TO_MOVE'
            return response

    # --------------------------
    #   Misc/Utility Functions
    # --------------------------
    def draw_feasible_path(self, points):
        """
        Generate a simple trajectory using Robotics Toolbox (mstraj).
        points: list [start_position, end_position]
        """
        via_points = np.array([[points[0]], [points[1]]])
        dt = 1.0 / self.sampling_frequency
        qd_max = self.max_velocity
        trajectory = rtb.tools.trajectory.mstraj(
            viapoints=via_points, dt=dt, tacc=0, qdmax=qd_max
        )
        return trajectory.q

    def update_control(self, error: float) -> float:
        """
        Basic P-controller output = Kp * error.
        """
        return self.Kp * error

    def collision_callback(self, msg: Bool):
        """
        Subscriber callback for collision detection.
        If collision is detected, we set state to ERROR (stopping in run()).
        """
        with self.collision_lock:
            if msg.data:
                if not self.collision_detected:
                    self.get_logger().error('COLLISION DETECTED!')
                self.collision_detected = True
            else:
                if self.collision_detected:
                    self.get_logger().info('Collision resolved')
                self.collision_detected = False

    def handle_estop_status(self, status: bool):
        """
        Callback from MachineMotion library when E-Stop is triggered/cleared.
        If triggered => Immediately go to ERROR state.
        """
        with self.state_transition_lock:
            if status is True:
                self.estop_triggered = True
                self.get_logger().error('E-STOP TRIGGERED!')
                self.mm.stopAxis(self.axis)
                self.state = self.State.ERROR
            else:
                self.get_logger().info('E-STOP CLEARED')
                self.estop_triggered = False

    def update_target_position_servo(self, msg: Float64):
        """
        Subscriber callback for position_servo_command topic.
        """
        with self.target_position_lock:
            self.target_joint_position_servo_message = msg

    def update_target_velocity(self, msg: Float64):
        """
        Subscriber callback for velocity_command topic.
        """
        with self.target_velocity_lock:
            self.last_velocity_command_time = self.get_clock().now()
            self.target_joint_velocity_message = msg


def main():
    """
    Entry point for the node.
    Parses arguments, initializes rclpy, creates the node, spins, and cleans up on exit.
    """
    parser = argparse.ArgumentParser(description='Vention State Machine (ROS 2)')
    parser.add_argument('--node_name', type=str, default='vention_node',
                        help='Name of the ROS 2 node')
    parser.add_argument('--vention_ip', type=str, required=True,
                        help='IP address of the Vention machine')
    args, unknown = parser.parse_known_args()

    rclpy.init(args=unknown)  # Initialize ROS 2

    node = VentionStateMachine(
        node_name=args.node_name,
        vention_ip=args.vention_ip,
        sampling_frequency=100.0
    )

    try:
        rclpy.spin(node)  # Blocks until shutdown
    except KeyboardInterrupt:
        node.get_logger().info('Keyboard interrupt received. Shutting down.')
    finally:
        node.mm.stopAllMotion()
        node.get_logger().info('Shutting down Vention State Machine node.')
        node.destroy_node()
        rclpy.shutdown()


if __name__ == '__main__':
    main()
